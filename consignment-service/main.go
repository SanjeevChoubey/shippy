package main

import (
	context "context"
	"log"
	"os"

	pb "github.com/Sanjeevchoubey/Shippy/consignment-service/proto/consignment"
	vesselProto "github.com/Sanjeevchoubey/Shippy/vessel-service/shippy-service-vessel/proto/vessel"

	//pb"github.com/SanjeevChoubey/go_basic_stuff/tree/Project/shippy/consignment-service/proto/consignment"
	"github.com/micro/go-micro"
)

// type repository interface {
// 	Create(*pb.Consignment) (*pb.Consignment, error)
// 	GetAll() []*pb.Consignment
// }

// Dummy Repository latter part this will be removed when we will started using dB
// type Repository struct {
// 	mu           sync.Mutex
// 	consignments []*pb.Consignment
// }

// type service struct {
// 	repo         repository
// 	vesselClient vesselProto.VesselServiceClient
// }

// func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error {
// 	res.Consignments = s.repo.GetAll()
// 	return nil
// }

// func (r *Repository) GetAll() []*pb.Consignment {
// 	return r.consignments
// }

// this method will be handled by gRPC
// func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error {
// 	// Check vessel id
// 	vr, err := s.vesselClient.FindAvailable(context.Background(), &vesselProto.Specification{
// 		MaxWeight: req.Weight,
// 		Capacity:  int32(len(req.Containers)),
// 	})
// 	if err != nil {
// 		return err
// 	}
// 	log.Println("found vessel", vr.Vessel.Name)
// 	req.VesselId = vr.Vessel.Id

// 	consignment, err := s.repo.Create(req)
// 	if err != nil {
// 		return err
// 	}
// 	res.Created = true
// 	res.Consignment = consignment
// 	return nil

// }

// // Create a new consignment
// func (r *Repository) Create(req *pb.Consignment) (*pb.Consignment, error) {
// 	r.mu.Lock()
// 	r.consignments = append(r.consignments, req)
// 	r.mu.Unlock()
// 	return req, nil
// }

const (
	port        = ":50051"
	defaultHost = "mongodb://localhost:27017"
)

func main() {
	//repo := &Repository{}
	//-grpc-----------------------------------------
	// //Setup gRPC server
	// lis, err := net.Listen("tcp", port)
	// if err != nil {
	// 	log.Fatalf("Failed to listen %v", err)
	// }

	// s := grpc.NewServer()

	// // Register our service to grpc server
	// // this will tie our implementation with autogenerated interface code
	// // for our protobuf defininition
	// pb.RegisterShippingServiceServer(s, &service{repo})

	// //Register Reflection services on GRPC server
	// reflection.Register(s)
	// log.Println("Running on Port: ", port)

	// if err := s.Serve(lis); err != nil {
	// 	log.Fatalf("Failed to serve %v", err)

	// }

	//  Go-Micro Instance --------------------------------------------
	srv := micro.NewService(
		micro.Name("shippy.service.consignment"),
	)
	srv.Init()

	uri := os.Getenv("DB_HOST")
	if uri == "" {
		uri = defaultHost
	}
	client, err := CreateClient(uri)
	if err != nil {
		log.Panic(err)
	}
	defer client.Disconnect(context.TODO())

	consignmentCollection := client.Database("shippy").Collection("consignments")

	repository := &MongoRepository{consignmentCollection}

	vesselClient := vesselProto.NewVesselServiceClient("shippy.service.vessel", srv.Client())
	h := &Handler{repository, vesselClient}

	pb.RegisterShippingServiceHandler(srv.Server(), h)

	// Run the Server
	log.Println("Running Servere at port :", port)
	if err := srv.Run(); err != nil {
		log.Println(err)
	}

}
